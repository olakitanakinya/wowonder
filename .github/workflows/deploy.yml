name: Deploy Wowonder
on:
  push:
    branches: [main]

env:
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/wowonder-laravel
  NAMESPACE: wowonder
  K8S_WORKER_IP: 44.220.139.238

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Fix config.php port
      run: |
        echo "=== Fixing config.php port ==="
        if [ -f "config.php" ]; then
          sed -i 's/:3008/:30080/g' config.php
          echo "Updated port from 3008 to 30080 in config.php"
        else
          echo "Creating config.php with correct port..."
          echo '<?php' > config.php
          echo '$sql_db_host = "mysql-service";' >> config.php
          echo '$sql_db_user = "wowonderuser";' >> config.php
          echo '$sql_db_pass = "Password123@24";' >> config.php
          echo '$sql_db_name = "wowonderdb";' >> config.php
          echo '$site_url = "http://44.220.139.238:30080";' >> config.php
          echo '$auto_redirect = true;' >> config.php
          echo '$purchase_code = "000000";' >> config.php
          echo '$siteEncryptKey = "eb733cdb4d769426e460bad9df6b824eee3416d7";' >> config.php
          echo '?>' >> config.php
        fi

    - name: Create Nginx configuration
      run: |
        echo "=== Creating Nginx Configuration ==="
        cat > nginx.conf << 'EOF'
        server {
            listen 80;
            server_name _;
            root /var/www/html;
            index index.php index.html;

            client_max_body_size 2024M;
            client_body_timeout 5000s;
            fastcgi_read_timeout 4000s;
            fastcgi_send_timeout 4000s;

            location / {
                try_files $uri $uri/ /index.php?$query_string;
            }

            location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|mp4|webm|ogg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
                try_files $uri $uri/ =404;
            }

            location /upload/ {
                alias /var/www/html/upload/;
                expires 1y;
                add_header Cache-Control "public, immutable";
                try_files $uri $uri/ =404;
            }

            location /assets/ {
                alias /var/www/html/assets/;
                expires 1y;
                add_header Cache-Control "public";
                try_files $uri $uri/ =404;
            }

            location /themes/ {
                alias /var/www/html/themes/;
                expires 1y;
                add_header Cache-Control "public";
                try_files $uri $uri/ =404;
            }

            location /admin-panel/ {
                alias /var/www/html/admin-panel/;
                try_files $uri $uri/ /admin-panel/index.php?$query_string;
            }

            location ~ \.php$ {
                include fastcgi_params;
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_index index.php;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
            }

            location ~ /\.ht {
                deny all;
            }
        }
        EOF
        echo "Nginx configuration created"
        echo "=== Verifying Nginx config ==="
        cat nginx.conf

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.DOCKER_IMAGE }}:latest
          ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: self-hosted
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Kubernetes
      uses: azure/setup-kubectl@v3

    - name: Configure kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
        kubectl config set-cluster kubernetes --server=https://54.159.42.214:6443 --insecure-skip-tls-verify=true
        kubectl get nodes

    - name: Cleanup previous deployment
      run: |
        echo "=== Cleaning previous deployment ==="
        kubectl delete all --all -n ${{ env.NAMESPACE }} --ignore-not-found=true
        kubectl delete pvc -n ${{ env.NAMESPACE }} --all --ignore-not-found=true
        kubectl delete pv --all --ignore-not-found=true
        kubectl delete namespace ${{ env.NAMESPACE }} --ignore-not-found=true
        sleep 10

    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.NAMESPACE }}
        echo "Namespace ${{ env.NAMESPACE }} created"

    - name: Setup storage directories on worker node
      run: |
        echo "=== Setting up storage directories on worker node ==="
        # Create storage directories on worker node using a Kubernetes job
        cat <<EOF | kubectl apply -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: storage-setup
          namespace: ${{ env.NAMESPACE }}
        spec:
          template:
            spec:
              nodeSelector:
                kubernetes.io/hostname: worker
              containers:
              - name: storage-setup
                image: busybox:1.35
                command:
                - /bin/sh
                - -c
                - |
                  echo "Creating storage directories on worker node..."
                  mkdir -p /mnt/data/wowonder /mnt/data/mysql
                  chmod -R 777 /mnt/data
                  echo "Storage directories created successfully"
                  ls -la /mnt/data/
                volumeMounts:
                - name: host-root
                  mountPath: /mnt
              restartPolicy: OnFailure
              volumes:
              - name: host-root
                hostPath:
                  path: /
                  type: Directory
        EOF

        # Wait for job completion
        echo "Waiting for storage setup job to complete..."
        kubectl wait --for=condition=complete job/storage-setup -n ${{ env.NAMESPACE }} --timeout=60s

        # Check job logs
        kubectl logs job/storage-setup -n ${{ env.NAMESPACE }}

        # Cleanup job
        kubectl delete job/storage-setup -n ${{ env.NAMESPACE }} --ignore-not-found=true

    - name: Deploy storage
      run: |
        echo "=== Deploying Storage ==="
        kubectl apply -f k8s/storage.yaml
        sleep 15

        echo "=== Storage Status ==="
        kubectl get pv,pvc -n ${{ env.NAMESPACE }} -o wide

        echo "=== PVC Details ==="
        kubectl describe pvc -n ${{ env.NAMESPACE }}

    - name: Deploy MySQL
      run: |
        echo "=== Deploying MySQL ==="
        kubectl apply -f k8s/mysql.yaml

        echo "=== Checking MySQL Pod Status ==="
        timeout 300s bash -c '
          while true; do
            POD_STATUS=$(kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o jsonpath="{.items[0].status.phase}" 2>/dev/null || echo "NotFound")
            POD_NODE=$(kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o jsonpath="{.items[0].spec.nodeName}" 2>/dev/null || echo "NoNode")

            echo "Pod Status: $POD_STATUS, Node: $POD_NODE"

            if [ "$POD_STATUS" = "Running" ]; then
              echo "✓ MySQL pod is running"
              break
            elif [ "$POD_STATUS" = "Pending" ]; then
              echo "⏳ MySQL pod is pending..."
              # Get detailed pod info
              MYSQL_POD=$(kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o jsonpath="{.items[0].metadata.name}" 2>/dev/null || echo "not-found")
              if [ "$MYSQL_POD" != "not-found" ]; then
                kubectl describe pod $MYSQL_POD -n ${{ env.NAMESPACE }}

                # Check events
                echo "=== Recent Events ==="
                kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
              fi
              sleep 20
            elif [ "$POD_STATUS" = "NotFound" ]; then
              echo "⏳ MySQL pod not created yet..."
              sleep 10
            else
              echo "⏳ MySQL pod status: $POD_STATUS"
              sleep 10
            fi
          done
        '

        # Wait for pod to be ready
        echo "Waiting for MySQL to be ready..."
        kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=600s

    - name: Check MySQL pod status
      run: |
        echo "=== MySQL Pod Status ==="
        kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o wide
        echo ""
        echo "=== MySQL Pod Logs ==="
        MYSQL_POD=$(kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')
        kubectl logs $MYSQL_POD -n ${{ env.NAMESPACE }} --tail=20

    - name: Initialize database
      run: |
        echo "=== Initializing Database ==="
        MYSQL_POD=$(kubectl get pods -l app=mysql -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')
        echo "MySQL pod: $MYSQL_POD"

        # Wait for MySQL to be ready to accept connections
        echo "Waiting for MySQL to accept connections..."
        timeout 180s bash -c "
          while ! kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysqladmin ping -uroot -prootpassword --silent; do
            echo '⏳ MySQL not ready yet...'
            sleep 10
          done
          echo '✓ MySQL is ready and accepting connections'
        "

        # Drop and recreate database to ensure clean state
        echo "Ensuring clean database state..."
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "DROP DATABASE IF EXISTS wowonderdb;"
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "CREATE DATABASE wowonderdb;"

        # Create user
        echo "Creating database user..."
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "DROP USER IF EXISTS 'wowonderuser'@'%';"
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "CREATE USER 'wowonderuser'@'%' IDENTIFIED BY 'Password123@24';"
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "GRANT ALL PRIVILEGES ON wowonderdb.* TO 'wowonderuser'@'%';"
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "FLUSH PRIVILEGES;"

        echo "✅ Database and user created successfully"
        kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword -e "SHOW DATABASES;"

        # Import SQL file with error handling for existing tables
        echo "Importing database schema from wowonderdb.sql..."
        if [ -f "wowonderdb.sql" ]; then
          echo "✓ wowonderdb.sql file found, size: $(wc -l < wowonderdb.sql) lines"

          # Copy file to pod
          echo "Copying SQL file to MySQL pod..."
          kubectl cp wowonderdb.sql ${{ env.NAMESPACE }}/$MYSQL_POD:/tmp/db.sql

          # Verify file was copied
          echo "Verifying file copy..."
          kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- ls -la /tmp/db.sql

          # Import database with force option to ignore errors
          echo "Importing database schema (ignoring duplicate table errors)..."
          kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- bash -c "mysql -uroot -prootpassword wowonderdb < /tmp/db.sql 2>/dev/null || echo 'Import completed with some warnings'"
          echo "✓ Database import completed"

          # Verify import
          echo "Verifying database tables:"
          kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword wowonderdb -e "SHOW TABLES;"

          # Count tables
          TABLE_COUNT=$(kubectl exec -n ${{ env.NAMESPACE }} $MYSQL_POD -- mysql -uroot -prootpassword wowonderdb -e "SHOW TABLES;" | wc -l)
          echo "✓ Database has $((TABLE_COUNT - 1)) tables"
        else
          echo "⚠ wowonderdb.sql not found, using empty database"
        fi

        echo "✅ Database initialization completed"

    - name: Deploy Nginx ConfigMap
      run: |
        echo "=== Deploying Nginx ConfigMap ==="
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: wowonder-nginx-config
          namespace: ${{ env.NAMESPACE }}
        data:
          default.conf: |
            server {
                listen 80;
                server_name _;
                root /var/www/html;
                index index.php index.html;

                client_max_body_size 2024M;
                client_body_timeout 5000s;
                fastcgi_read_timeout 4000s;
                fastcgi_send_timeout 4000s;

                location / {
                    try_files \$uri \$uri/ /index.php?\$query_string;
                }

                location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|mp4|webm|ogg)$ {
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                    try_files \$uri \$uri/ =404;
                }

                location /upload/ {
                    alias /var/www/html/upload/;
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                    try_files \$uri \$uri/ =404;
                }

                location /assets/ {
                    alias /var/www/html/assets/;
                    expires 1y;
                    add_header Cache-Control "public";
                    try_files \$uri \$uri/ =404;
                }

                location /themes/ {
                    alias /var/www/html/themes/;
                    expires 1y;
                    add_header Cache-Control "public";
                    try_files \$uri \$uri/ =404;
                }

                location /admin-panel/ {
                    alias /var/www/html/admin-panel/;
                    try_files \$uri \$uri/ /admin-panel/index.php?\$query_string;
                }

                location ~ \.php$ {
                    include fastcgi_params;
                    fastcgi_pass 127.0.0.1:9000;
                    fastcgi_index index.php;
                    fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
                    fastcgi_param PATH_INFO \$fastcgi_path_info;
                }

                location ~ /\.ht {
                    deny all;
                }
            }
        EOF
        echo "✓ Nginx ConfigMap deployed"

    - name: Deploy application
      run: |
        echo "=== Deploying Application ==="
        # Create a temporary file with the image replaced
        cat <<EOF | sed "s|\$DOCKER_IMAGE|${{ env.DOCKER_IMAGE }}|g" | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: wowonder-app
          namespace: ${{ env.NAMESPACE }}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: wowonder-app
          template:
            metadata:
              labels:
                app: wowonder-app
            spec:
              nodeSelector:
                kubernetes.io/hostname: worker
              containers:
              - name: wowonder-app
                image: \$DOCKER_IMAGE:latest
                ports:
                - containerPort: 80
                volumeMounts:
                - name: nginx-config
                  mountPath: /etc/nginx/conf.d/default.conf
                  subPath: default.conf
                env:
                - name: DB_HOST
                  value: "mysql-service"
                - name: DB_DATABASE
                  value: "wowonderdb"
                - name: DB_USERNAME
                  value: "wowonderuser"
                - name: DB_PASSWORD
                  value: "Password123@24"
                - name: SITE_URL
                  value: "http://44.220.139.238:30080"
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "250m"
                  limits:
                    memory: "1Gi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /index.php
                    port: 80
                  initialDelaySeconds: 60
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /index.php
                    port: 80
                  initialDelaySeconds: 30
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 3
              volumes:
              - name: nginx-config
                configMap:
                  name: wowonder-nginx-config
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: wowonder-service
          namespace: ${{ env.NAMESPACE }}
        spec:
          type: NodePort
          selector:
            app: wowonder-app
          ports:
          - port: 80
            targetPort: 80
            nodePort: 30080
        EOF

        echo "Waiting for application pod..."
        timeout 180s bash -c '
          while true; do
            POD_STATUS=$(kubectl get pods -l app=wowonder-app -n ${{ env.NAMESPACE }} -o jsonpath="{.items[0].status.phase}" 2>/dev/null || echo "NotFound")
            if [ "$POD_STATUS" = "Running" ]; then
              echo "✓ Application pod is running"
              break
            elif [ "$POD_STATUS" = "NotFound" ]; then
              echo "⏳ Application pod not found yet..."
            else
              echo "⏳ Application pod status: $POD_STATUS"
            fi
            sleep 10
          done
        '

    - name: Verify application files
      run: |
        echo "=== Verifying Application Files ==="
        APP_POD=$(kubectl get pods -l app=wowonder-app -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "NOT_FOUND")

        if [ "$APP_POD" != "NOT_FOUND" ]; then
          echo "Checking application structure:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/
          echo "Checking if themes directory exists:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/themes/ || echo "Themes directory not found"
          echo "Checking if index.php exists:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/index.php || echo "index.php not found"
        else
          echo "❌ Application pod not found for verification"
        fi

    - name: Create config in pod
      run: |
        echo "=== Creating Config in Pod ==="
        APP_POD=$(kubectl get pods -l app=wowonder-app -n ${{ env.NAMESPACE }} -o name 2>/dev/null || echo "NOT_FOUND")

        if [ "$APP_POD" != "NOT_FOUND" ]; then
          echo "Checking if application files exist..."
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/ || echo "Application directory empty"
          
          # Only create config.php if it doesn't exist or we need to update it
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '<?php' > /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$sql_db_host = \"mysql-service\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$sql_db_user = \"wowonderuser\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$sql_db_pass = \"Password123@24\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$sql_db_name = \"wowonderdb\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$site_url = \"http://44.220.139.238:30080\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$auto_redirect = true;' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$purchase_code = \"000000\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '\$siteEncryptKey = \"eb733cdb4d769426e460bad9df6b824eee3416d7\";' >> /var/www/html/config.php"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- sh -c "echo '?>' >> /var/www/html/config.php"

          # Set permissions
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- chown www-data:www-data /var/www/html/config.php
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- chmod 644 /var/www/html/config.php

          echo "✓ Configuration files updated"
        else
          echo "❌ Cannot create config - application pod not found"
        fi

    - name: Test database connection from app
      run: |
        echo "=== Testing Database Connection from Application ==="
        APP_POD=$(kubectl get pods -l app=wowonder-app -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "NOT_FOUND")

        if [ "$APP_POD" != "NOT_FOUND" ]; then
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- php -r "\
          \$conn = new mysqli('mysql-service', 'wowonderuser', 'Password123@24', 'wowonderdb', 3306);\
          if (\$conn->connect_error) {\
              echo '❌ DATABASE ERROR: ' . \$conn->connect_error;\
              exit(1);\
          } else {\
              echo '✓ DATABASE SUCCESS: Connected to MySQL';\
              \$result = \$conn->query('SHOW TABLES');\
              if (\$result && \$result->num_rows > 0) {\
                  echo '✓ Database has tables: ' . \$result->num_rows;\
              } else {\
                  echo '⚠ Database is empty or tables query failed';\
              }\
              \$conn->close();\
          }\
          " || echo "Database test completed"
        else
          echo "❌ Cannot test database - application pod not found"
        fi

    - name: Debug application
      run: |
        echo "=== Debugging Application ==="
        APP_POD=$(kubectl get pods -l app=wowonder-app -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "NOT_FOUND")
        
        if [ "$APP_POD" != "NOT_FOUND" ]; then
          echo "Checking application structure:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/
          echo "Checking themes directory:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ls -la /var/www/html/themes/ || echo "Themes directory not found"
          
          echo "Checking Nginx configuration:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- cat /etc/nginx/conf.d/default.conf
          
          echo "Checking Nginx logs:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- tail -20 /var/log/nginx/error.log || echo "No Nginx error log"
          
          echo "Checking PHP-FPM status:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ps aux | grep php || echo "PHP-FPM not running"
          
          echo "Checking Nginx status:"
          kubectl exec -n ${{ env.NAMESPACE }} $APP_POD -- ps aux | grep nginx || echo "Nginx not running"
        else
          echo "Application pod not found for debugging"
        fi

    - name: Test application
      run: |
        echo "=== Testing Application ==="
        echo "Waiting for application to be fully ready..."
        sleep 30

        echo "--- Testing Specific Endpoints ---"
        
        # Test if PHP is working
        echo "Testing PHP execution:"
        curl -s -o /dev/null -w "PHP Index: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/index.php
        
        # Test static files with correct paths
        echo "Testing CSS files:"
        curl -s -o /dev/null -w "Wowonder CSS: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/themes/wowonder/stylesheet/style.css || echo "Wowonder CSS not found"
        curl -s -o /dev/null -w "Sunshine CSS: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/themes/sunshine/stylesheet/style.css || echo "Sunshine CSS not found"
        
        # Test JavaScript files
        echo "Testing JavaScript files:"
        curl -s -o /dev/null -w "Main JS: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/themes/wowonder/javascript/script.js || echo "Main JS not found"
        
        # Test upload directory
        echo "Testing upload directory:"
        curl -s -o /dev/null -w "Upload Dir: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/upload/ || echo "Upload directory not accessible"
        
        # Test assets
        echo "Testing assets:"
        curl -s -o /dev/null -w "Assets Dir: %{http_code}\n" http://${{ env.K8S_WORKER_IP }}:30080/assets/ || echo "Assets directory not accessible"

        # Test with verbose output to see redirects
        echo "--- Verbose Testing ---"
        curl -v http://${{ env.K8S_WORKER_IP }}:30080/ 2>&1 | grep -E "(Location:|HTTP/)"

    - name: Show status
      run: |
        echo "=== 🎉 FINAL DEPLOYMENT STATUS ==="
        echo ""
        echo "📊 CLUSTER STATUS:"
        kubectl get all -n ${{ env.NAMESPACE }}

        echo ""
        echo "💾 STORAGE STATUS:"
        kubectl get pv,pvc -n ${{ env.NAMESPACE }}

        echo ""
        echo "🌐 APPLICATION URLS:"
        echo "   Main Site:      http://${{ env.K8S_WORKER_IP }}:30080/"
        echo "   Welcome Page:   http://${{ env.K8S_WORKER_IP }}:30080/welcome"
        echo "   Registration:   http://${{ env.K8S_WORKER_IP }}:30080/register"
        echo "   Login:          http://${{ env.K8S_WORKER_IP }}:30080/login"

        echo ""
        echo "✅ DEPLOYMENT COMPLETE"
